package manifest

import "github.com/pkg/errors"

type (

	// DataSource represents a datasource appsync can connect to
	DataSource struct {
		Dynamo *DynamoSource `yaml:"dynamo,omitempty"`
		RDS    *RDSSource    `yaml:"rds,omitempty"`
		Lambda *LambdaSource `yaml:"lambda,omitempty"`
	}

	// ==== DYNAMO ==============================

	// DynamoSource represents a dynamodb datasource
	DynamoSource struct {
		DisableBackup bool   `yaml:"disableBackup,omitempty"`
		HashKey       string `yaml:"hashKey,omitempty"`
		SortKey       string `yaml:"sortKey,omitempty"`
	}

	// ==== RDS =================================

	// RDSSource represents an RDS datasource
	RDSSource struct {
		Existing     bool   `yaml:"existing"`
		Identifier   string `yaml:"dbIdentifier"`
		DatabaseName string `yaml:"databaseName"`
		Schema       string `yaml:"schema"`

		// These must be set if Existing=true
		// Otherwise these are going to autogenerated
		ServiceRoleARN string `yaml:"serviceRoleArn,omitempty"`
	}

	// ==== LAMBDA ==============================

	// LambdaSource represents a lambda source
	LambdaSource struct{} // TODO
)

// GetSource returns whichever data source sub type has been declared.
// If more than one have managed to be declared, it will be returned in order
// of preference: Dynamo -> RDS -> Lambda -> nil
func (ds *DataSource) GetSource() interface{} {
	switch {
	case ds.Dynamo != nil:
		return ds.Dynamo
	case ds.RDS != nil:
		return ds.RDS
	case ds.Lambda != nil:
		return ds.Lambda
	}
	return nil
}

// Validate ensures a datasource contains valid configuration
func (ds *DataSource) Validate() error {
	switch {
	case ds.Dynamo != nil:
		if ds.Dynamo.HashKey == "" {
			return errors.New("dynamo datasource must declare a hashKey")
		}
	// TODO validate other sources
	// ...
	default:
		return errors.New("unknown/unsupported datasource")
	}
	return nil
}
